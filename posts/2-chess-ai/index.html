<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Chess AI Essentials: From Randomness to Strategy üé≤ | Angel Gong</title>
<meta name="keywords" content="">
<meta name="description" content="What Makes a Chess AI? Creating an effective Chess AI involves understanding and implementing several core principles. In this section, we will introduce the fundamental aspects that enable a Chess AI to function, including the necessity of making moves, leveraging Python&rsquo;s chess library, and the importance of move evaluation.
1. Reading the Board The core of any Chess AI is its ability to make decisions and execute moves on the chessboard autonomously.">
<meta name="author" content="">
<link rel="canonical" href="https://angelg8.github.io/chess-ai-blog/posts/2-chess-ai/">
<link crossorigin="anonymous" href="/chess-ai-blog/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://angelg8.github.io/chess-ai-blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://angelg8.github.io/chess-ai-blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://angelg8.github.io/chess-ai-blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://angelg8.github.io/chess-ai-blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://angelg8.github.io/chess-ai-blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://angelg8.github.io/chess-ai-blog/posts/2-chess-ai/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Chess AI Essentials: From Randomness to Strategy üé≤" />
<meta property="og:description" content="What Makes a Chess AI? Creating an effective Chess AI involves understanding and implementing several core principles. In this section, we will introduce the fundamental aspects that enable a Chess AI to function, including the necessity of making moves, leveraging Python&rsquo;s chess library, and the importance of move evaluation.
1. Reading the Board The core of any Chess AI is its ability to make decisions and execute moves on the chessboard autonomously." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://angelg8.github.io/chess-ai-blog/posts/2-chess-ai/" /><meta property="article:section" content="posts" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Chess AI Essentials: From Randomness to Strategy üé≤"/>
<meta name="twitter:description" content="What Makes a Chess AI? Creating an effective Chess AI involves understanding and implementing several core principles. In this section, we will introduce the fundamental aspects that enable a Chess AI to function, including the necessity of making moves, leveraging Python&rsquo;s chess library, and the importance of move evaluation.
1. Reading the Board The core of any Chess AI is its ability to make decisions and execute moves on the chessboard autonomously."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://angelg8.github.io/chess-ai-blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Chess AI Essentials: From Randomness to Strategy üé≤",
      "item": "https://angelg8.github.io/chess-ai-blog/posts/2-chess-ai/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Chess AI Essentials: From Randomness to Strategy üé≤",
  "name": "Chess AI Essentials: From Randomness to Strategy üé≤",
  "description": "What Makes a Chess AI? Creating an effective Chess AI involves understanding and implementing several core principles. In this section, we will introduce the fundamental aspects that enable a Chess AI to function, including the necessity of making moves, leveraging Python\u0026rsquo;s chess library, and the importance of move evaluation.\n1. Reading the Board The core of any Chess AI is its ability to make decisions and execute moves on the chessboard autonomously.",
  "keywords": [
    
  ],
  "articleBody": "What Makes a Chess AI? Creating an effective Chess AI involves understanding and implementing several core principles. In this section, we will introduce the fundamental aspects that enable a Chess AI to function, including the necessity of making moves, leveraging Python‚Äôs chess library, and the importance of move evaluation.\n1. Reading the Board The core of any Chess AI is its ability to make decisions and execute moves on the chessboard autonomously. Before making any moves, the AI must be able to assess the current board state and determine a list of possible moves. We will utilize Python‚Äôs built-in chess library to handle all the game logic for our AI. Specifically, it allows us to access the current board state and generate a list of valid moves that the AI can consider.\n2. ‚ÄúHello World‚Äù To demonstrate the basic functionality of running chess games using the GUI and Python‚Äôs chess library, we start with a simple ‚ÄúHello World‚Äù AI which we will can Random AI, since it selects its moves entirely at random from the list of valid moves. While not a competitive strategy, it serves as a foundational step in verifying that our setup works correctly and that the AI can interact with the chessboard and make moves, and also serving as a baseline control to measure the performance of future AI‚Äôs we make.\nimport chess import random from abc import ABC, abstractmethod from typing import List class ChessAI(ABC): \"\"\" Represents a chess AI that can play a game of chess. \"\"\" @abstractmethod def find_move(self, board: chess.Board) -\u003e chess.Move: pass class RandomAI(ChessAI): \"\"\" Represents a chess AI that makes random moves. \"\"\" def find_move(self, board: chess.Board) -\u003e chess.Move: \"\"\" Generates a random move. Returns: (move): A random move. \"\"\" legal_moves: List[chess.Move] = list(board.legal_moves) return random.choice(legal_moves) And now for a demonstration! 3. Evaluating Moves To step up our AI‚Äôs performance, we need some way to evaluate moves. Ideally, we want our Chess AI to evaluate moves to determine which is the best, and select that move. The simplest form of move evaluation might involve assigning static values to pieces and positions. For instance, capturing a queen is typically more valuable than capturing a pawn. More advanced evaluations can consider positional advantages, control of the board, potential threats, and long-term strategic plans, but for now, we will use rely solely on piece material values.\nWe will use standard point assignments for pieces. The king is a special case where it is always best to capture the king, as it results in the player winning the game, so we can assign an arbitrary large value to it such as 10,000 to ensure such a move will always be evaluated as the best.\nPIECE_VALUES = { chess.PAWN: 100, chess.KNIGHT: 300, chess.BISHOP: 300, chess.ROOK: 500, chess.QUEEN: 900, chess.KING: 10000 } 4. Introducing the Minimax Algorithm The Minimax algorithm is a recursive tree search used in decision-making and game theory. It provides a way for our Chess AI to make optimal moves by simulating future moves and counter-moves. The algorithm operates under the assumption that both players will play optimally.\nHere‚Äôs how the Minimax algorithm works:\nRecursion and Depth: The algorithm simulates moves up to a certain depth, alternating between maximizing and minimizing players. In chess, these are typically the two opponents. Evaluation Function: At the leaves of the recursion tree (when the maximum depth is reached or the game is over), the board is evaluated using the piece values we defined. Maximizing and Minimizing: The AI assumes the opponent will make the best possible counter-move. Therefore, it aims to maximize its score while the opponent aims to minimize the AI‚Äôs score. Here is a Minimax AI implementation using our existing ChessAI class and Python‚Äôs chess library. Evaluating to a depth of 3 means we will look at all our possible moves, and for each move, we will consider all our opponent‚Äôs possible responses to that move. Then, we will consider all the moves we can make in response to our opponent‚Äôs follow-up move, and we select the move that maximizes the material gain for us (or minimize loss).\nMINIMAX_DEPTH = 3 def get_material_score(board: chess.Board) -\u003e float: \"\"\" Evaluates a chess board using chess piece values. Arguments: board (chess.Board): A chess board to evaluate Returns: (float): The evaluation value of the board \"\"\" if board.is_checkmate(): return float('-inf') if board.turn == chess.WHITE else float('inf') elif board.is_stalemate() or board.is_insufficient_material(): return 0.0 evaluation: float = 0.0 for square in chess.SQUARES: piece: Optional[chess.Piece] = board.piece_at(square) if piece is not None: if piece.color == chess.WHITE: evaluation += PIECE_VALUES[piece.piece_type] else: evaluation -= PIECE_VALUES[piece.piece_type] class MinimaxAI(ChessAI): \"\"\" Represents a chess AI that makes moves based on a minimax algorithm. \"\"\" def __init__(self, evaluation_function: Callable = get_material_score): self.depth = MINIMAX_DEPTH self.is_playing_white: bool = True def __minimax(self, board: chess.Board, depth: int, maximizing_player: bool) -\u003e float: \"\"\" Performs a minimax algorithm to determine the best move for a plater given a board. Arguments: board (chess.Board): The board to evaluate depth (int): What depth to search to maximizing_player (bool): Is this is maximizing player (i.e. white to move) Returns: (float): The minimax evaluation for the given player \"\"\" if depth == 0 or board.is_game_over(): return self.evaluation_function(board) legal_moves: List[chess.Move] = list(board.legal_moves) if maximizing_player: value = float('-inf') for move in legal_moves: board.push(move) value = max(value, self.__minimax(board, depth - 1, not maximizing_player)) board.pop() return value else: value = float('inf') for move in legal_moves: board.push(move) value = min(value, self.__minimax(board, depth - 1, not maximizing_player)) board.pop() return value def find_move(self, board: chess.Board) -\u003e chess.Move: \"\"\" Finds the best move for a given board. Arguments: board (chess.Board): A board to evaluate Returns: (chess.Move): The best move given the board \"\"\" legal_moves: List[chess.Move] = list(board.legal_moves) random.shuffle(legal_moves) best_move: chess.Move = legal_moves[0] best_value: float = float('-inf') if self.is_playing_white else float('inf') for move in legal_moves: board.push(move) value: float = self.__minimax(board, self.depth - 1, not self.is_playing_white) board.pop() if (self.is_playing_white and value \u003e best_value) or (not self.is_playing_white and value \u003c best_value): best_value = value best_move = move return best_move Now, we will pit Minimax AI playing as white against Random AI playing as black!\nAlready, we can see that Minimax plays much better than Random. It tries to capture pieces to increase its material advantage, but not if it means immediately losing a piece in return. We also observe that there is sometimes a slight delay before Minimax makes its move, due it its increased computational complexity.\nThe time complexity of the Minimax algorithm is O(b^d) where:\nb is the branching factor (number of possible moves in any given turn; usually averages 30-40 in a game of chess) d is the depth (number of turns we want to look ahead) Assuming a branching factor of 30, and using our depth of 3, we will need to calculate an average of 30^3 = 27,000 moves per turn, a big step up from just randomly selecting a move with the Random AI!\nEvery time we increasing our our depth, we increase the computational complexity by a polynomial factor. Here we will increase Minimax‚Äôs depth to 4 to illustrate the increase in computation time. I (a human presumably) will play the first move as white, and Minimax will play the second move as black.\nMinimax plays noticeably slower now, but fortunately, we still have some tricks up our sleeves to improve our chess AI‚Äôs!\n",
  "wordCount" : "1213",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://angelg8.github.io/chess-ai-blog/posts/2-chess-ai/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Angel Gong",
    "logo": {
      "@type": "ImageObject",
      "url": "https://angelg8.github.io/chess-ai-blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://angelg8.github.io/chess-ai-blog/" accesskey="h" title="Angel Gong (Alt + H)">Angel Gong</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://angelg8.github.io/chess-ai-blog/">Home</a>&nbsp;¬ª&nbsp;<a href="https://angelg8.github.io/chess-ai-blog/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Chess AI Essentials: From Randomness to Strategy üé≤
    </h1>
    <div class="post-meta">6 min

</div>
  </header> 
  <div class="post-content"><h3 id="what-makes-a-chess-ai">What Makes a Chess AI?<a hidden class="anchor" aria-hidden="true" href="#what-makes-a-chess-ai">#</a></h3>
<p>Creating an effective Chess AI involves understanding and implementing several core principles. In this section, we will introduce the fundamental aspects that enable a Chess AI to function, including the necessity of making moves, leveraging Python&rsquo;s chess library, and the importance of move evaluation.</p>
<hr>
<h4 id="1-reading-the-board">1. Reading the Board<a hidden class="anchor" aria-hidden="true" href="#1-reading-the-board">#</a></h4>
<p>The core of any Chess AI is its ability to make decisions and execute moves on the chessboard autonomously. Before making any moves, the AI must be able to assess the current board state and determine a list of possible moves. We will utilize Python&rsquo;s built-in chess library to handle all the game logic for our AI. Specifically, it allows us to access the current board state and generate a list of valid moves that the AI can consider.</p>
<hr>
<h4 id="2-hello-world">2. &ldquo;Hello World&rdquo;<a hidden class="anchor" aria-hidden="true" href="#2-hello-world">#</a></h4>
<p>To demonstrate the basic functionality of running chess games using the GUI and Python&rsquo;s chess library, we start with a simple &ldquo;Hello World&rdquo; AI which we will can Random AI, since it selects its moves entirely at random from the list of valid moves. While not a competitive strategy, it serves as a foundational step in verifying that our setup works correctly and that the AI can interact with the chessboard and make moves, and also serving as a baseline control to measure the performance of future AI&rsquo;s we make.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> chess
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> abc <span style="color:#f92672">import</span> ABC, abstractmethod
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> typing <span style="color:#f92672">import</span> List
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChessAI</span>(ABC):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Represents a chess AI that can play a game of chess.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@abstractmethod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_move</span>(self, board: chess<span style="color:#f92672">.</span>Board) <span style="color:#f92672">-&gt;</span> chess<span style="color:#f92672">.</span>Move:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RandomAI</span>(ChessAI):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Represents a chess AI that makes random moves.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_move</span>(self, board: chess<span style="color:#f92672">.</span>Board) <span style="color:#f92672">-&gt;</span> chess<span style="color:#f92672">.</span>Move:
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Generates a random move.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (move): A random move.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        legal_moves: List[chess<span style="color:#f92672">.</span>Move] <span style="color:#f92672">=</span> list(board<span style="color:#f92672">.</span>legal_moves)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> random<span style="color:#f92672">.</span>choice(legal_moves)
</span></span></code></pre></div><p>And now for a demonstration!





<center>
    <iframe width="482" height="480" src="https://www.youtube.com/embed/_bup9BI_fBo?modestbranding=1"
        frameborder="0" allowfullscreen></iframe>
</center></p>
<hr>
<h4 id="3-evaluating-moves">3. Evaluating Moves<a hidden class="anchor" aria-hidden="true" href="#3-evaluating-moves">#</a></h4>
<p>To step up our AI&rsquo;s performance, we need some way to evaluate moves. Ideally, we want our Chess AI to evaluate moves to determine which is the best, and select that move. The simplest form of move evaluation might involve assigning static values to pieces and positions. For instance, capturing a queen is typically more valuable than capturing a pawn. More advanced evaluations can consider positional advantages, control of the board, potential threats, and long-term strategic plans, but for now, we will use rely solely on piece material values.</p>
<p>We will use standard point assignments for pieces. The king is a special case where it is always best to capture the king, as it results in the player winning the game, so we can assign an arbitrary large value to it such as 10,000 to ensure such a move will always be evaluated as the best.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>PIECE_VALUES <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    chess<span style="color:#f92672">.</span>PAWN: <span style="color:#ae81ff">100</span>,
</span></span><span style="display:flex;"><span>    chess<span style="color:#f92672">.</span>KNIGHT: <span style="color:#ae81ff">300</span>,
</span></span><span style="display:flex;"><span>    chess<span style="color:#f92672">.</span>BISHOP: <span style="color:#ae81ff">300</span>,
</span></span><span style="display:flex;"><span>    chess<span style="color:#f92672">.</span>ROOK: <span style="color:#ae81ff">500</span>,
</span></span><span style="display:flex;"><span>    chess<span style="color:#f92672">.</span>QUEEN: <span style="color:#ae81ff">900</span>,
</span></span><span style="display:flex;"><span>    chess<span style="color:#f92672">.</span>KING: <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h4 id="4-introducing-the-minimax-algorithm">4. Introducing the Minimax Algorithm<a hidden class="anchor" aria-hidden="true" href="#4-introducing-the-minimax-algorithm">#</a></h4>
<p>The Minimax algorithm is a recursive tree search used in decision-making and game theory. It provides a way for our Chess AI to make optimal moves by simulating future moves and counter-moves. The algorithm operates under the assumption that both players will play optimally.</p>
<p>Here&rsquo;s how the Minimax algorithm works:</p>
<ol>
<li><strong>Recursion and Depth:</strong> The algorithm simulates moves up to a certain depth, alternating between maximizing and minimizing players. In chess, these are typically the two opponents.</li>
<li><strong>Evaluation Function:</strong> At the leaves of the recursion tree (when the maximum depth is reached or the game is over), the board is evaluated using the piece values we defined.</li>
<li><strong>Maximizing and Minimizing:</strong> The AI assumes the opponent will make the best possible counter-move. Therefore, it aims to maximize its score while the opponent aims to minimize the AI&rsquo;s score.</li>
</ol>
<p>Here is a Minimax AI implementation using our existing ChessAI class and Python&rsquo;s chess library. Evaluating to a depth of 3 means we will look at all our possible moves, and for each move, we will consider all our opponent&rsquo;s possible responses to that move. Then, we will consider all the moves we can make in response to our opponent&rsquo;s follow-up move, and we select the move that maximizes the material gain for us (or minimize loss).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>MINIMAX_DEPTH <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_material_score</span>(board: chess<span style="color:#f92672">.</span>Board) <span style="color:#f92672">-&gt;</span> float:
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Evaluates a chess board using chess piece values.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Arguments:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            board (chess.Board): A chess board to evaluate
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (float): The evaluation value of the board
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> board<span style="color:#f92672">.</span>is_checkmate():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> float(<span style="color:#e6db74">&#39;-inf&#39;</span>) <span style="color:#66d9ef">if</span> board<span style="color:#f92672">.</span>turn <span style="color:#f92672">==</span> chess<span style="color:#f92672">.</span>WHITE <span style="color:#66d9ef">else</span> float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">elif</span> board<span style="color:#f92672">.</span>is_stalemate() <span style="color:#f92672">or</span> board<span style="color:#f92672">.</span>is_insufficient_material():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>        evaluation: float <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> square <span style="color:#f92672">in</span> chess<span style="color:#f92672">.</span>SQUARES:
</span></span><span style="display:flex;"><span>            piece: Optional[chess<span style="color:#f92672">.</span>Piece] <span style="color:#f92672">=</span> board<span style="color:#f92672">.</span>piece_at(square)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> piece <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> piece<span style="color:#f92672">.</span>color <span style="color:#f92672">==</span> chess<span style="color:#f92672">.</span>WHITE:
</span></span><span style="display:flex;"><span>                    evaluation <span style="color:#f92672">+=</span> PIECE_VALUES[piece<span style="color:#f92672">.</span>piece_type]
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                    evaluation <span style="color:#f92672">-=</span> PIECE_VALUES[piece<span style="color:#f92672">.</span>piece_type]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MinimaxAI</span>(ChessAI):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Represents a chess AI that makes moves based on a minimax algorithm.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> __init__(self, evaluation_function: Callable <span style="color:#f92672">=</span> get_material_score):
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>depth <span style="color:#f92672">=</span> MINIMAX_DEPTH
</span></span><span style="display:flex;"><span>        self<span style="color:#f92672">.</span>is_playing_white: bool <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__minimax</span>(self, board: chess<span style="color:#f92672">.</span>Board, depth: int, maximizing_player: bool) <span style="color:#f92672">-&gt;</span> float:
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Performs a minimax algorithm to determine the best move for a plater given a board.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Arguments:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            board (chess.Board): The board to evaluate
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            depth (int): What depth to search to
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            maximizing_player (bool): Is this is maximizing player (i.e. white to move)
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (float): The minimax evaluation for the given player
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> depth <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> board<span style="color:#f92672">.</span>is_game_over():
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>evaluation_function(board)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        legal_moves: List[chess<span style="color:#f92672">.</span>Move] <span style="color:#f92672">=</span> list(board<span style="color:#f92672">.</span>legal_moves)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> maximizing_player:
</span></span><span style="display:flex;"><span>            value <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;-inf&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> move <span style="color:#f92672">in</span> legal_moves:
</span></span><span style="display:flex;"><span>                board<span style="color:#f92672">.</span>push(move)
</span></span><span style="display:flex;"><span>                value <span style="color:#f92672">=</span> max(value, self<span style="color:#f92672">.</span>__minimax(board, depth <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">not</span> maximizing_player))
</span></span><span style="display:flex;"><span>                board<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> value
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            value <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> move <span style="color:#f92672">in</span> legal_moves:
</span></span><span style="display:flex;"><span>                board<span style="color:#f92672">.</span>push(move)
</span></span><span style="display:flex;"><span>                value <span style="color:#f92672">=</span> min(value, self<span style="color:#f92672">.</span>__minimax(board, depth <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">not</span> maximizing_player))
</span></span><span style="display:flex;"><span>                board<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">find_move</span>(self, board: chess<span style="color:#f92672">.</span>Board) <span style="color:#f92672">-&gt;</span> chess<span style="color:#f92672">.</span>Move:
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;&#34;&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Finds the best move for a given board.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Arguments:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            board (chess.Board): A board to evaluate
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">            (chess.Move): The best move given the board
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>        legal_moves: List[chess<span style="color:#f92672">.</span>Move] <span style="color:#f92672">=</span> list(board<span style="color:#f92672">.</span>legal_moves)
</span></span><span style="display:flex;"><span>        random<span style="color:#f92672">.</span>shuffle(legal_moves)
</span></span><span style="display:flex;"><span>        best_move: chess<span style="color:#f92672">.</span>Move <span style="color:#f92672">=</span> legal_moves[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>        best_value: float <span style="color:#f92672">=</span> float(<span style="color:#e6db74">&#39;-inf&#39;</span>) <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>is_playing_white <span style="color:#66d9ef">else</span> float(<span style="color:#e6db74">&#39;inf&#39;</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> move <span style="color:#f92672">in</span> legal_moves:
</span></span><span style="display:flex;"><span>            board<span style="color:#f92672">.</span>push(move)
</span></span><span style="display:flex;"><span>            value: float <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>__minimax(board, self<span style="color:#f92672">.</span>depth <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>is_playing_white)
</span></span><span style="display:flex;"><span>            board<span style="color:#f92672">.</span>pop()
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (self<span style="color:#f92672">.</span>is_playing_white <span style="color:#f92672">and</span> value <span style="color:#f92672">&gt;</span> best_value) <span style="color:#f92672">or</span> (<span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>is_playing_white <span style="color:#f92672">and</span> value <span style="color:#f92672">&lt;</span> best_value):
</span></span><span style="display:flex;"><span>                best_value <span style="color:#f92672">=</span> value
</span></span><span style="display:flex;"><span>                best_move <span style="color:#f92672">=</span> move
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> best_move
</span></span></code></pre></div><p>Now, we will pit Minimax AI playing as white against Random AI playing as black!</p>





<center>
    <iframe width="482" height="480" src="https://www.youtube.com/embed/LU4vLB5hyMU?modestbranding=1"
        frameborder="0" allowfullscreen></iframe>
</center>
<p>Already, we can see that Minimax plays much better than Random. It tries to capture pieces to increase its material advantage, but not if it means immediately losing a piece in return. We also observe that there is sometimes a slight delay before Minimax makes its move, due it its increased computational complexity.</p>
<p>The time complexity of the Minimax algorithm is <em>O(b^d)</em> where:</p>
<ul>
<li><em>b</em> is the branching factor (number of possible moves in any given turn; usually averages 30-40 in a game of chess)</li>
<li><em>d</em> is the depth (number of turns we want to look ahead)</li>
</ul>
<p>Assuming a branching factor of 30, and using our depth of 3, we will need to calculate an average of <em>30^3 = 27,000</em> moves per turn, a big step up from just randomly selecting a move with the Random AI!</p>
<p>Every time we increasing our our depth, we increase the computational complexity by a polynomial factor. Here we will increase Minimax&rsquo;s depth to 4 to illustrate the increase in computation time. I (a human presumably) will play the first move as white, and Minimax will play the second move as black.</p>





<center>
    <iframe width="482" height="480" src="https://www.youtube.com/embed/hZVM4kY99JE?modestbranding=1"
        frameborder="0" allowfullscreen></iframe>
</center>
<p>Minimax plays noticeably slower now, but fortunately, we still have some tricks up our sleeves to improve our chess AI&rsquo;s!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://angelg8.github.io/chess-ai-blog/posts/1-prologue/">
    <span class="title">¬´ Prev</span>
    <br>
    <span>The First Move: Angel&#39;s Gambit ‚ôüÔ∏è</span>
  </a>
  <a class="next" href="https://angelg8.github.io/chess-ai-blog/posts/3-chess-ai/">
    <span class="title">Next ¬ª</span>
    <br>
    <span>Rooting for Success: Improving Tree Search üå≤</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://angelg8.github.io/chess-ai-blog/">Angel Gong</a></span> ¬∑ 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
